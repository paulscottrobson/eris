<html><head></head><body>
<hr><h1>!</h1>
<p><b>(data addr - )</b></p><p> Write the data second on the stack to the address on the top of the stack</p>
<hr><h1>#</h1>
<p><b>( - data)</b></p><p> # accesses basic variables ; it compiles code to push the variable following it in the source on top of the stack. #test is the equivalent of test @ in FORTH.</p>
<hr><h1>*</h1>
<p><b>(n1 n2 - n1*n2)</b></p><p> Multiply the top two values on the stack and push the result on the stack</p>
<hr><h1>+</h1>
<p><b>(n1 n2 - n1+n2)</b></p><p> Add the top two values on the stack and push the result on the stack</p>
<hr><h1>+!</h1>
<p><b>(data addr - )</b></p><p> Add the data second on the stack to the address on the top of the stack</p>
<hr><h1>++</h1>
<p><b>(n - m)</b></p><p> Increment the top of the stack</p>
<hr><h1>-</h1>
<p><b>(n1 n2 - sub)</b></p><p> Subtract the top of the stack from the second on the stack and push the result on the stack</p>
<hr><h1>--</h1>
<p><b>(n - m)</b></p><p> Decrement the top of the stack</p>
<hr><h1>.</h1>
<p><b>(n - )</b></p><p> Print the top value of the stack in signed decimal</p>
<hr><h1>/</h1>
<p><b>(n1 n2 - div)</b></p><p> Divide the second on stack by the top of the stack and push the result on the stack</p>
<hr><h1>0-</h1>
<p><b>(n - -n)</b></p><p> Negate the top of the stack</p>
<hr><h1>0<</h1>
<p><b>(n - t)</b></p><p> Check the top of the stack ; drop the value ; if less than zero push -1 , if non zero push false</p>
<hr><h1>0=</h1>
<p><b>(n - t)</b></p><p> Check the top of the stack ; drop the value ; if zero push -1 , if non zero push false</p>
<hr><h1><</h1>
<p><b>(n1 n2 - t)</b></p><p> Compare the top two stack values and drop both, replacing them with -1 if the second value on the stack is less than the first</p>
<hr><h1><<</h1>
<p><b>(n - m)</b></p><p> Shift the top of the stack left</p>
<hr><h1><=</h1>
<p><b>(n1 n2 - t)</b></p><p> Compare the top two stack values and drop both, replacing them with -1 if the second value on the stack is less than or equal to the first</p>
<hr><h1><></h1>
<p><b>(n1 n2 - t)</b></p><p> Compare the top two stack values and drop both, replacing them with -1 if the second value on the stack is not equal to the first</p>
<hr><h1>=</h1>
<p><b>(n1 n2 - t)</b></p><p> Compare the top two stack values and drop both, replacing them with -1 if the second value on the stack is equal to the first</p>
<hr><h1>></h1>
<p><b>(n1 n2 - t)</b></p><p> Compare the top two stack values and drop both, replacing them with -1 if the second value on the stack is greater than the first</p>
<hr><h1>>=</h1>
<p><b>(n1 n2 - t)</b></p><p> Compare the top two stack values and drop both, replacing them with -1 if the second value on the stack is greater than or equal to the first</p>
<hr><h1>>></h1>
<p><b>(n - m)</b></p><p> Shift the top of the stack right logically (so bit 15 is always clear)</p>
<hr><h1>@</h1>
<p><b>(addr - data)</b></p><p> Read the word at the given address</p>
<hr><h1>^</h1>
<p><b>(data - )</b></p><p> # accesses basic variables ; it compiles code to store the top of the stack in the variable following it in the source. ^test is the equivalent of test ! in FORTH.</p>
<hr><h1>and</h1>
<p><b>(n1 n2 - n1&n2)</b></p><p> Binary and the top two values on the stack and push the result on the stack</p>
<hr><h1>break</h1>
<p><b>(-)</b></p><p> Compiles a break into the code.</p>
<hr><h1>bswap</h1>
<p><b>(n - b)</b></p><p> Swap the upper and lower byte of the top of the stack</p>
<hr><h1>cr</h1>
<p><b>( - )</b></p><p> Print a carriage return</p>
<hr><h1>drop</h1>
<p><b>(m n - m)</b></p><p> Drop the top of the stack</p>
<hr><h1>dup</h1>
<p><b>(n - n n)</b></p><p> Duplicate the top value on the stack</p>
<hr><h1>else</h1>
<p><b>( - )</b></p><p> Marks the start of the else code, which is executed if the IF test failed. This is optional</p>
<hr><h1>emit</h1>
<p><b>(n - )</b></p><p> Output the top of the stack are a character</p>
<hr><h1>for</h1>
<p><b>(n - )</b></p><p> Starts a loop which executes a fixed number of times, counting down from n-1 to zero. Cannot be nested 10 FOR ...... NEXT executes the code for 9 8 7 ... 0</p>
<hr><h1>i</h1>
<p><b>( - n)</b></p><p> Get the current index value to the top of the stack. This value is held on the return stack so cannot be accessed inside another method.</p>
<hr><h1>if</h1>
<p><b>(test - )</b></p><p> If the top of the stack is true execute the code that is between here and either ELSE or THEN. These cannot be nested <test> IF ... ELSE ... THEN</p>
<hr><h1>max</h1>
<p><b>(n1 n2 - n)</b></p><p> Push the higher of the top two values on the stack on the stack</p>
<hr><h1>min</h1>
<p><b>(n1 n2 - n)</b></p><p> Push the lower of the top two values on the stack on the stack</p>
<hr><h1>mod</h1>
<p><b>(n1 n2 - mod)</b></p><p> Divide the second on stack by the top of the stack and push the modulus on the stack</p>
<hr><h1>next</h1>
<p><b>( - )</b></p><p> Next marks the end of the loop.</p>
<hr><h1>nip</h1>
<p><b>(m n - n)</b></p><p> Drop the second element on the stack</p>
<hr><h1>not</h1>
<p><b>(n - ~n)</b></p><p> Binary not (1's complement) the top of the stack</p>
<hr><h1>or</h1>
<p><b>(n1 n2 - n1|n2)</b></p><p> Binary or the top two values on the stack and push the result on the stack</p>
<hr><h1>over</h1>
<p><b>(m n - m n m)</b></p><p> Copy the second value on the stack to the top of the stack.</p>
<hr><h1>repeat</h1>
<p><b>( - )</b></p><p> Marks the start of the conditional loop. REPEAT ...... <test> UNTIL. These cannot be nested.</p>
<hr><h1>rot</h1>
<p><b>( n1 n2 n3 â€” n2 n3 n1 )</b></p><p> Rotate the third item on the stack to the top</p>
<hr><h1>swap</h1>
<p><b>(m n - n m)</b></p><p> Swap the top two values on the stack</p>
<hr><h1>sys</h1>
<p><b>(<params> count address - r0)</b></p><p> Calls routine address, with count parameters which are pushed on the stack backwards (e.g. R3v R2v R1v R0v 4 code.address SYS) ; these are loaded into R0-R4. The value in R0 on return is put on the top of the stack</p>
<hr><h1>then</h1>
<p><b>( - )</b></p><p> Marks the end of the if structure.</p>
<hr><h1>until</h1>
<p><b>(test - )</b></p><p> Marks the end of the conditional loop, using the top of the stack as a test, loops back to the top if the test is zero</p>
<hr><h1>xor</h1>
<p><b>(n1 n2 - n1^n2)</b></p><p> Binary xor the top two values on the stack and push the result on the stack</p>
</body>
